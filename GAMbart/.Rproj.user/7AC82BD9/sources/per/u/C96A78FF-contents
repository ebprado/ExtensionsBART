library(splines)
library(MCMCpack)
library(mvtnorm)
library(Matrix)
library(devtools)
  install()
  load_all()
  document()
  check()
  build()
install_github("ebprado/MOTR-BART/MOTRbart")
install_github("ebprado/MOTR-BART/GAMbart")
library(GAMbart)
library(MOTRbart)

# Simulate a Friedman data set
friedman_data = function(n, num_cov, sd_error){
  x = matrix(runif(n*num_cov),n,num_cov)
  y = 10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2+10*x[,4]+5*x[,5] + rnorm(n, sd=sd_error)
  return(list(y = y,
              x = x))
}
# Training data
data = friedman_data(200, 10, 1)
y = data$y
x = data$x

# Test data
data_test = friedman_data(100, 10, 1)
y.test = data_test$y
x.test = data_test$x

# Run GAM-BART
set.seed(99)
fit.gam.bart = gam_bart(x, y, str = 'original', ntrees = 10, nburn = 100, npost = 100, df=5, dg=3, ancestors = FALSE, penalty = 'ridge')
plot(y,apply(fit.gam.bart$y_hat,2,mean));abline(0,1)
cor(y,apply(fit.gam.bart$y_hat,2,mean))
yhat.test = predict_gam_bart(fit.gam.bart, x, x.test, type = 'mean')
plot(y.test, yhat.test); abline(0,1)
cor(y.test, yhat.test)
plot(fit.gam.bart$tau_betas[,1],type='l')
plot(fit.gam.bart$tau_betas[,2],type='l')
plot(fit.gam.bart$sigma2, type='l')
fit.gam.bart$trees[[100]]
# Run MOTR-BART 
fit.motr.bart = motr_bart(x, y, ntrees = 10, nburn = 100, npost = 100, ancestors = FALSE)
plot(y,apply(fit.motr.bart$y_hat,2,mean));abline(0,1)
cor(y,apply(fit.motr.bart$y_hat,2,mean))

# Run GAM-BART for classification
set.seed(01)
y = ifelse(y > median(y), 1, 0)
fit.motr.bart = gam_bart_class(x, y, ntrees = 10, nburn = 100, npost = 100, str = 'splines')
yhat = apply(fit.motr.bart$y_hat, 2, mean)
cor(y, yhat)

datatest = data.frame(cbind(y,x))

aa = gam(y ~ s(V2) + s(V3) + s(V4) + s(V5) + s(V6) + s(V7,bs='ts') + s(V8,bs='ts') + s(V9,bs='ts'), data = datatest, select = FALSE)
round(aa$coefficients, digits = 2)
summary(aa)

aa1 = gam(y ~ s(V2) + s(V3) + s(V4) + s(V5) + s(V6) + s(V7,bs='ts') + s(V8,bs='ts') + s(V9,bs='ts'), data = datatest, select = TRUE)
round(aa1$coefficients, digits = 2)
summary(aa1)

plot(round(aa$coefficients, digits = 2),round(aa1$coefficients, digits = 2))
abline(0,1)
bb = x[,1]

xx = smooth.construct2(s(bb, bs='ps'), data = list(bb = bb), knots=s(bb))
D = xx$D
p = diff(diag(10), differences = 1)
cc = eigen(t(p)%*%p)
U = cc$vectors
L = cc$values

round(U%*%diag(L)%*%t(U))



x=c(-3,-2.8,-2.7,-2,-1.5,-1,0,1,1.2,1.5,2,2.7,2.8,3)
y=c(-27,-21,-16,1,7.5,7,1,-5,-5.2,-4,1,19,23,28)
plot(x,y, main='Problem 2')

lines(x,lm(y ~ x)$fitted.values, col=2)
lines(x,lm(y ~ poly(x,2))$fitted.values, col=3)
lines(x,lm(y ~ poly(x,3))$fitted.values, col=4)
lines(x,lm(y ~ poly(x,4))$fitted.values, col=5)

lm(y ~ poly(x,3)
